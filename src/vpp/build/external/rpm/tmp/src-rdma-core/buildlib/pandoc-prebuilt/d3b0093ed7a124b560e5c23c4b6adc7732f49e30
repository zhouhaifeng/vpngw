.\" Automatically generated by Pandoc 2.5
.\"
.TH "mlx5dv_query_port" "3" "" "" ""
.hy
.SH NAME
.PP
mlx5dv_query_port \- Query non standard attributes of IB device port.
.SH SYNOPSIS
.IP
.nf
\f[C]
#include <infiniband/mlx5dv.h>

int mlx5dv_query_port(struct ibv_context *context,
              uint32_t port_num,
              struct mlx5dv_port *info);
\f[R]
.fi
.SH DESCRIPTION
.PP
Query port info which can be used for some device commands over the DEVX
interface and when directly accessing the hardware resources.
.PP
A function that lets a user query hardware and configuration attributes
associated with the port.
.SH USAGE
.PP
A user should provide the port number to query.
On successful query \f[I]flags\f[R] will store a subset of the requested
attributes which are supported/relevant for that port.
.SH ARGUMENTS
.TP
.B \f[I]context\f[R]
RDMA device context to work on.
.TP
.B \f[I]port_num\f[R]
Port number to query.
.TP
.B ## \f[I]info\f[R]
Stores the returned attributes from the kernel.
.IP
.nf
\f[C]
struct mlx5dv_port {
    uint64_t flags;
    uint16_t vport;
    uint16_t vport_vhca_id;
    uint16_t esw_owner_vhca_id;
    uint16_t rsvd0;
    uint64_t vport_steering_icm_rx;
    uint64_t vport_steering_icm_tx;
    struct mlx5dv_reg reg_c0;
};
\f[R]
.fi
.TP
.B \f[I]flags\f[R]
Bit field of attributes, on successful query \f[I]flags\f[R] stores the
valid filled attributes.
.RS
.PP
MLX5DV_QUERY_PORT_VPORT: The vport number of that port.
.PP
MLX5DV_QUERY_PORT_VPORT_VHCA_ID: The VHCA ID of \f[I]vport_num\f[R].
.PP
MLX5DV_QUERY_PORT_ESW_OWNER_VHCA_ID: The E\-Switch owner of
\f[I]vport_num\f[R].
.PP
MLX5DV_QUERY_PORT_VPORT_STEERING_ICM_RX: The ICM RX address when
directing traffic.
.PP
MLX5DV_QUERY_PORT_VPORT_STEERING_ICM_TX: The ICM TX address when
directing traffic.
.PP
MLX5DV_QUERY_PORT_VPORT_REG_C0: Register C0 value used to identify
egress of \f[I]vport_num\f[R].
.RE
.TP
.B \f[I]vport\f[R]
The VPORT number of that port.
.TP
.B \f[I]vport_vhca_id\f[R]
The VHCA ID of \f[I]vport_num\f[R].
.TP
.B \f[I]rsvd0\f[R]
A reserved field.
Not to be used.
.TP
.B \f[I]esw_owner_vhca_id\f[R]
The E\-Switch owner of \f[I]vport_num\f[R].
.TP
.B \f[I]vport_steering_ica_rx\f[R]
The ICM RX address when directing traffic.
.TP
.B \f[I]vport_steering_icm_tx\f[R]
The ICM TX address when directing traffic.
.TP
.B ## reg_c0
Register C0 value used to identify traffic of \f[I]vport_num\f[R].
.IP
.nf
\f[C]
struct mlx5dv_reg {
        uint32_t value;
        uint32_t mask;
};
\f[R]
.fi
.TP
.B \f[I]value\f[R]
The value that should be used as match.
.TP
.B \f[I]mask\f[R]
The mask that should be used when matching.
.SH RETURN VALUE
.PP
returns 0 on success, or the value of errno on failure (which indicates
the failure reason).
.SH EXAMPLE
.IP
.nf
\f[C]
for (i = 1; i <= ports; i++) {
    ret = mlx5dv_query_port(context, i, &port_info);
    if (ret) {
        printf(\[dq]Error querying port %d\[rs]n\[dq], i);
        break;
    }

    printf(\[dq]Port: %d:\[rs]n\[dq], i);

    if (port_info.flags & MLX5DV_QUERY_PORT_VPORT)
        printf(\[dq]\[rs]tvport_num: 0x%x\[rs]n\[dq], port_info.vport_num);

    if (port_info.flags & MLX5DV_QUERY_PORT_VPORT_REG_C0)
        printf(\[dq]\[rs]treg_c0: val: 0x%x mask: 0x%x\[rs]n\[dq],
                port_info.reg_c0.value,
                port_info.reg_c0.mask);
}
\f[R]
.fi
.PP
Mark Bloch <mbloch@nvidia.com>
